set_1 = {5, 4, 3, 2}
set_2 = {6, 7, 5, 4, 3, 7, 10, 12}

set_1.add(1)  # Добавляем элемент 1 в set_1

set_3 = set_2 & set_1  # Возвращаем пересечение 2-х множеств. Аналог intersection

set_3.clear()  # Очищаем множество. Остается пустое.

set_3 = set_1.copy()  # Создаем shallow копию множества

set_3.difference(set_1)  # Возвращаем отличия двух множеств. Множества остаются без изменений

set_3.difference_update(set_2)  # Убираем элементы, которые есть в множестве set_2 из set_3.

set_1.discard(8)  # Удаляем выбранный элемент из множества. Так как указанного элемента нет - множество не изменится
# При этом не будет ошибки, так предусмотрено логикой метода

set_4 = set_1.union(set_2)  # Возвращаем множество с элементами обоих множеств (множества set_1 set_2 не изменены)
set_4.intersection_update(set_3)  # Удаляем из множества значения, которых нет в set_3

set_3.isdisjoint(set_2)  # Возвращаем True или False в зависимости от наличия пересечения между множествами

set_3.issubset(set_2)  # Проверяем входит ли полностью множество set_3 в set_2

set_3.issuperset(set_2)  # Проверяем входит ли полность множество set_2 в set_3

set_4.pop()  # Удаляем случайный элемент множества

set_1.remove(5)  # Удаляем выбраннный элемент из множества. Если бы элемент отсутствовал - была бы ошибка

set_4.update([12, 34, 44])  # Добавляем значения итерируемого объект в множество

set_4.symmetric_difference(set_2)  # Возвращаем множество состоящие из отличающихся элементов set_2 и set_4

set_4.symmetric_difference_update(set_2)  # Изменяем set_4 заменяя на отличающиеся элементы set_2 и set_4

print(set_1, set_2, set_3, set_4, sep='\n')
